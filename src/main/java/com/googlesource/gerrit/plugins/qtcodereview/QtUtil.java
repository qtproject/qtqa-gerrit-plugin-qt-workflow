// Copyright (C) 2011 The Android Open Source Project
// Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
// Copyright (C) 2021 The Qt Company
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.googlesource.gerrit.plugins.qtcodereview;

import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.flogger.FluentLogger;
import com.google.gerrit.common.FooterConstants;
import com.google.gerrit.exceptions.StorageException;
import com.google.gerrit.extensions.registration.DynamicItem;
import com.google.gerrit.extensions.restapi.RestApiException;
import com.google.gerrit.entities.BranchNameKey;
import com.google.gerrit.entities.Change;
import com.google.gerrit.entities.PatchSet;
import com.google.gerrit.entities.Project;
import com.google.gerrit.server.ChangeMessagesUtil;
import com.google.gerrit.server.IdentifiedUser;
import com.google.gerrit.server.data.ChangeAttribute;
import com.google.gerrit.server.extensions.events.GitReferenceUpdated;
import com.google.gerrit.server.events.ChangeEvent;
import com.google.gerrit.server.events.EventDispatcher;
import com.google.gerrit.server.events.EventFactory;
import com.google.gerrit.server.git.CodeReviewCommit;
import com.google.gerrit.server.git.MergeUtil;
import com.google.gerrit.server.notedb.ChangeNotes;
import com.google.gerrit.server.permissions.PermissionBackendException;
import com.google.gerrit.server.project.NoSuchRefException;
import com.google.gerrit.server.project.ProjectCache;
import com.google.gerrit.server.project.ProjectState;
import com.google.gerrit.server.query.change.ChangeData;
import com.google.gerrit.server.query.change.InternalChangeQuery;
import com.google.gerrit.server.submit.IntegrationException;
import com.google.gerrit.server.update.BatchUpdate;
import com.google.gerrit.server.update.UpdateException;
import com.google.gerrit.server.util.time.TimeUtil;
import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.Singleton;
import java.io.IOException;
import java.sql.Timestamp;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;
import org.eclipse.jgit.errors.MissingObjectException;
import org.eclipse.jgit.lib.CommitBuilder;
import org.eclipse.jgit.lib.Constants;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.ObjectInserter;
import org.eclipse.jgit.lib.ObjectReader;
import org.eclipse.jgit.lib.PersonIdent;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.lib.RefUpdate;
import org.eclipse.jgit.lib.RefUpdate.Result;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.merge.MergeStrategy;
import org.eclipse.jgit.merge.ThreeWayMerger;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.transport.ReceiveCommand;

/** Utility methods for working with git and database. */
@Singleton
public class QtUtil {

  private static final FluentLogger logger = FluentLogger.forEnclosingClass();

  public static final String R_HEADS = "refs/heads/";
  public static final String R_STAGING = "refs/staging/";
  public static final String R_BUILDS = "refs/builds/";
  public static final String TAG_CI = ChangeMessagesUtil.AUTOGENERATED_TAG_PREFIX + "qt:ci";
  public static final String TAG_ADMINCHANGE =
      ChangeMessagesUtil.AUTOGENERATED_TAG_PREFIX + "qt:adminchange";
  public static final String TAG_REOPENED =
      ChangeMessagesUtil.AUTOGENERATED_TAG_PREFIX + "qt:reopened";

  private final Provider<InternalChangeQuery> queryProvider;
  private final GitReferenceUpdated referenceUpdated;
  private final BatchUpdate.Factory updateFactory;
  private final ChangeNotes.Factory changeNotesFactory;
  private final DynamicItem<EventDispatcher> eventDispatcher;
  private final EventFactory eventFactory;
  private final MergeUtil.Factory mergeUtilFactory;
  private final ProjectCache projectCache;
  private final QtCherryPickPatch qtCherryPickPatch;
  private final QtChangeUpdateOp.Factory qtUpdateFactory;
  private final QtEmailSender qtEmailSender;

  @Inject
  QtUtil(
      Provider<InternalChangeQuery> queryProvider,
      GitReferenceUpdated referenceUpdated,
      BatchUpdate.Factory updateFactory,
      ChangeNotes.Factory changeNotesFactory,
      EventFactory eventFactory,
      DynamicItem<EventDispatcher> eventDispatcher,
      MergeUtil.Factory mergeUtilFactory,
      ProjectCache projectCache,
      QtCherryPickPatch qtCherryPickPatch,
      QtChangeUpdateOp.Factory qtUpdateFactory,
      QtEmailSender qtEmailSender) {
    this.queryProvider = queryProvider;
    this.referenceUpdated = referenceUpdated;
    this.updateFactory = updateFactory;
    this.changeNotesFactory = changeNotesFactory;
    this.eventDispatcher = eventDispatcher;
    this.eventFactory = eventFactory;
    this.mergeUtilFactory = mergeUtilFactory;
    this.projectCache = projectCache;
    this.qtCherryPickPatch = qtCherryPickPatch;
    this.qtUpdateFactory = qtUpdateFactory;
    this.qtEmailSender = qtEmailSender;
  }

  public static class MergeConflictException extends Exception {
    private static final long serialVersionUID = 1L;

    public MergeConflictException(final String message) {
      super(message);
    }
  }

  public static class BranchNotFoundException extends Exception {
    private static final long serialVersionUID = 1L;

    public BranchNotFoundException(final String message) {
      super(message);
    }
  }

  public static Project.NameKey getProjectKey(final String project) {
    String projectName = project;
    if (project.endsWith(Constants.DOT_GIT_EXT)) {
      projectName = project.substring(0, project.length() - Constants.DOT_GIT_EXT.length());
    }
    return Project.nameKey(projectName);
  }

  /**
   * Creates a branch key including ref prefix.
   *
   * @param project Project for the branch key.
   * @param prefix Expected prefix.
   * @param branch Branch name with or without prefix.
   * @return Branch name key with prefix.
   */
  public static BranchNameKey getNameKeyLong(
      final String project, final String prefix, final String branch) {
    final Project.NameKey projectKey = getProjectKey(project);
    if (branch.startsWith(prefix)) {
      return BranchNameKey.create(projectKey, branch);
    } else {
      return BranchNameKey.create(projectKey, prefix + branch);
    }
  }

  /**
   * Creates a branch key without any prefix.
   *
   * @param project Project for the branch key.
   * @param prefix Prefix to remove.
   * @param branch Branch name with or without prefix.
   * @return Branch name key without prefix.
   */
  public static BranchNameKey getNameKeyShort(
      final String project, final String prefix, final String branch) {
    final Project.NameKey projectKey = getProjectKey(project);
    if (branch.startsWith(prefix)) {
      return BranchNameKey.create(projectKey, branch.substring(prefix.length()));
    } else {
      return BranchNameKey.create(projectKey, branch);
    }
  }

  public static boolean branchExists(Repository git, final BranchNameKey branch)
      throws IOException {
    return git.getRefDatabase().getRef(branch.branch()) != null;
  }

  /**
   * Gets a staging branch for a branch.
   *
   * @param branch Branch under refs/heads. E.g. refs/heads/master. Can be short name.
   * @return Matching staging branch. E.g. refs/staging/master
   */
  public static BranchNameKey getStagingBranch(final BranchNameKey branch) {
    return getBranchWithNewPrefix(branch, R_HEADS, R_STAGING);
  }

  private static BranchNameKey getBranchWithNewPrefix(
      final BranchNameKey branch, final String oldPrefix, final String newPrefix) {
    final String ref = branch.branch();

    if (ref.startsWith(oldPrefix)) {
      // Create new ref replacing the old prefix with new.
      return BranchNameKey.create(
          branch.project(), newPrefix + ref.substring(oldPrefix.length()));
    }
    // Treat the ref as short name.
    return BranchNameKey.create(branch.project(), newPrefix + ref);
  }

  public static Result createStagingBranch(Repository git, final BranchNameKey sourceBranch) {
    try {
      final String sourceBranchName;
      if (sourceBranch.branch().startsWith(R_HEADS)) {
        sourceBranchName = sourceBranch.branch();
      } else {
        sourceBranchName = R_HEADS + sourceBranch.branch();
      }

      final String stagingBranch = R_STAGING + sourceBranch.shortName();

      return updateRef(git, stagingBranch, sourceBranchName, true);
    } catch (NoSuchRefException | IOException e) {
      return null;
    }
  }

  /**
   * Creates a build ref. Build refs are stored under refs/builds.
   *
   * @param git Git repository.
   * @param stagingBranch Staging branch to create the build ref from. Can be short name.
   * @param newBranch Build ref name, under refs/builds. Can be short name.
   * @return
   * @throws IOException
   * @throws NoSuchRefException
   */
  public Result createBuildRef(
      Repository git,
      IdentifiedUser user,
      final Project.NameKey projectKey,
      final BranchNameKey stagingBranch,
      final BranchNameKey newBranch)
      throws IOException, NoSuchRefException {
    final String stagingBranchName;
    if (stagingBranch.branch().startsWith(R_STAGING)) {
      stagingBranchName = stagingBranch.branch();
    } else {
      stagingBranchName = R_STAGING + stagingBranch.branch();
    }

    final String buildBranchName;
    if (newBranch.branch().startsWith(R_BUILDS)) {
      buildBranchName = newBranch.branch();
    } else {
      buildBranchName = R_BUILDS + newBranch.branch();
    }

    Ref sourceRef = git.getRefDatabase().getRef(stagingBranchName);
    if (sourceRef == null) {
      throw new NoSuchRefException(stagingBranchName);
    }

    RefUpdate refUpdate = git.updateRef(buildBranchName);
    refUpdate.setNewObjectId(sourceRef.getObjectId());
    refUpdate.setForceUpdate(false);
    RefUpdate.Result result = refUpdate.update();

    // send ref created event
    referenceUpdated.fire(projectKey, refUpdate, ReceiveCommand.Type.CREATE, user.state());

    return result;
  }

  private static Result updateRef(
      Repository git, final String ref, final String newValue, final boolean force)
      throws IOException, NoSuchRefException {
    Ref sourceRef = git.getRefDatabase().getRef(newValue);
    if (sourceRef == null) {
      throw new NoSuchRefException(newValue);
    }

    return updateRef(git, ref, sourceRef.getObjectId(), force);
  }

  public static Result updateRef(
      Repository git, final String ref, final ObjectId id, final boolean force)
      throws IOException, NoSuchRefException {
    RefUpdate refUpdate = git.updateRef(ref);
    refUpdate.setNewObjectId(id);
    refUpdate.setForceUpdate(force);
    RefUpdate.Result result = refUpdate.update();
    return result;
  }

  private static String getChangeId(RevCommit commit) {
    List<String> changeIds = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String changeId = null;
    if (!changeIds.isEmpty()) changeId = changeIds.get(0);
    return changeId;
  }

  private ChangeData findChangeFromList(String changeId, List<ChangeData> changes) {
    for (ChangeData item : changes) {
      if (item.change().getKey().get().equals(changeId)) return item;
    }
    return null;
  }

  // Step backwards from the ref and return change list in the same order
  private List<ChangeData> arrangeOrderLikeInRef(
      Repository git, ObjectId refObj, ObjectId tipObj, List<ChangeData> changeList)
      throws Exception {
    List<ChangeData> results = new ArrayList<ChangeData>();
    int count = 0;
    logger.atInfo().log("Arranging change order to match original");

    try {
      if (refObj.equals(tipObj)) return results;

      RevWalk revWalk = new RevWalk(git);
      RevCommit branchHead = revWalk.parseCommit(tipObj);
      RevCommit commit = revWalk.parseCommit(refObj);

      do {
        count++;
        String changeId = getChangeId(commit);

        if (commit.getParentCount() == 0) {
          commit = null; // something is going wrong, just exit
         } else {
          if (changeId == null && commit.getParentCount() > 1) {
            changeId = getChangeId(revWalk.parseCommit(commit.getParent(1)));
          }
          ChangeData change = findChangeFromList(changeId, changeList);
          if (change != null) results.add(0, change);

          // It can always be trusted that parent in index 0 is the correct one
          commit = revWalk.parseCommit(commit.getParent(0));
        }
      } while (commit != null  && !revWalk.isMergedInto(commit, branchHead) && count < 100);
    } catch (Exception e) {
      throw new Exception("arranging change order failed: " + e.getMessage());
    }

    if (count == 100) throw new Exception("arranging change order failed: too many commits");

    return results;
  }

  private ObjectId pickChangesToStagingRef(
      Repository git, final Project.NameKey projectKey, List<ChangeData> changes, ObjectId tipObj)
      throws Exception {
    ObjectId newId = tipObj;
    logger.atInfo().log("Cherry-picking changes on top of %s", tipObj.name());

    try {
      for (ChangeData item : changes) {
        Change change = item.change();
        logger.atInfo().log("cherry-picking %s", change.getKey());
        PatchSet p = item.currentPatchSet();
        ObjectId srcId = git.resolve(p.commitId().name());
        newId =
            qtCherryPickPatch
                .cherryPickPatch(
                    item,
                    projectKey,
                    srcId,
                    newId,
                    false, // allowFastForward
                    null, // newStatus
                    null, // defaultMessage
                    null, // inputMessage
                    TAG_CI // tag
                    )
                .toObjectId();
      }
    } catch (Exception e) {
      throw new Exception("cherry-picking changes failed: " + e.getMessage());
    }
    return newId;
  }

  // Step backwards from staging head and find commit that can be reused
  private ObjectId findReusableStagingHead(
      Repository git,
      ObjectId stagingHead,
      ObjectId branchHead,
      List<ChangeData> stagedChanges) {
    ObjectId reusableHead = null;
    logger.atInfo().log("Finding reusable staging commit");
    if (stagingHead.equals(branchHead)) return branchHead;

    try {
      RevWalk revWalk = new RevWalk(git);
      RevCommit branch = revWalk.parseCommit(branchHead);
      RevCommit commit = revWalk.parseCommit(stagingHead);
      logger.atInfo().log("Branch head: " + branch.name());
      logger.atInfo().log("Staging head: " + commit.name());

      if (!revWalk.isMergedInto(branch, commit)) return branchHead;

      int count = 0;
      do {
        count++;
        String changeId = getChangeId(commit);
        ChangeData change = findChangeFromList(changeId, stagedChanges);
        if (change != null) {
          if (reusableHead == null) reusableHead = commit;
        } else reusableHead = null;

        if (commit.getParentCount() > 0) {
          // It can always be trusted that parent in index 0 is the correct one
          commit = revWalk.parseCommit(commit.getParent(0));
        } else commit = null;
      } while (commit != null && !commit.equals(branchHead) && count < 100);

      if (count == 100) throw new Exception("can't find ref, too many commits");
    } catch (Exception e) {
      reusableHead = null;
      logger.atSevere().log("Finding reusable staging commit failed: %s", e.getMessage());
    }

    if (reusableHead == null) {
      reusableHead = branchHead;
      logger.atInfo().log("Reusable staging commit not found");
    }

    return reusableHead;
  }

  public void rebuildStagingBranch(
      Repository git,
      IdentifiedUser user,
      final Project.NameKey projectKey,
      final BranchNameKey stagingBranchKey,
      final BranchNameKey destBranchShortKey)
      throws MergeConflictException {
    InternalChangeQuery query = null;
    List<ChangeData> changes_staged = null;
    List<ChangeData> changes_to_cherrypick = null;
    ObjectId oldStageRef = null;
    ObjectId branchRef = null;
    ObjectId newStageRef = null;
    String stagingBranchName = null;

    logger.atInfo().log("Rebuilding %s", stagingBranchKey.branch());

    try {
      stagingBranchName = stagingBranchKey.branch();
      oldStageRef = git.resolve(stagingBranchName);
      branchRef = git.resolve(destBranchShortKey.branch());

      query = queryProvider.get();
      changes_staged = query.byBranchStatus(destBranchShortKey, Change.Status.STAGED);
    } catch (IOException e) {
      logger.atSevere().log(
          "rebuild staging ref %s db query failed. Exception %s",
          stagingBranchKey, e);
      throw new MergeConflictException("fatal: " + e.getMessage());
    }

    try {
      logger.atInfo().log("staging ref %s reseted to %s", stagingBranchKey.branch(),
          destBranchShortKey.branch());

      Result result = QtUtil.createStagingBranch(git, destBranchShortKey);
      if (result == null)
        throw new NoSuchRefException("Cannot create staging ref %s" + stagingBranchName);

      newStageRef = findReusableStagingHead(git, oldStageRef, branchRef, changes_staged);
      logger.atInfo().log("reused staging ref is %s", newStageRef.name());

      changes_to_cherrypick = arrangeOrderLikeInRef(git, oldStageRef, newStageRef, changes_staged);
      String changeStr = "";
      for (ChangeData item : changes_to_cherrypick) changeStr += " " + item.change().getKey();
      logger.atInfo().log("changes to be cherry-picked: %s", changeStr);

      newStageRef = pickChangesToStagingRef(git, projectKey, changes_to_cherrypick, newStageRef);
    } catch (Exception e) {
      logger.atSevere().log("rebuild staging ref %s failed: %s", stagingBranchKey.branch(),
          e.getMessage());
      newStageRef = branchRef;
      String message =
          "Merge conflict in staging branch. Status changed back to new. Please stage again.";
      QtChangeUpdateOp op =
          qtUpdateFactory.create(
              Change.Status.NEW, Change.Status.STAGED, message, null, null, null);
      try (BatchUpdate u = updateFactory.create(projectKey, user, TimeUtil.nowTs())) {
        for (ChangeData item : changes_staged) {
          Change change = item.change();
          logger.atInfo().log("change %s back to NEW", change.getKey());
          u.addOp(change.getId(), op);
        }
        u.execute();

      } catch (UpdateException | RestApiException ex) {
        logger.atSevere().log("Failed to update change status %s", ex);
      }

      for (ChangeData item : changes_staged) {
        Change change = item.change();
        qtEmailSender.sendBuildFailedEmail(projectKey, change.getId(), user.getAccountId(),
            message);
      }
    }

    try {
      RefUpdate refUpdate = git.updateRef(stagingBranchName);
      refUpdate.setNewObjectId(newStageRef);
      refUpdate.update();
      logger.atInfo().log("Ref %s points now to %s", stagingBranchKey.branch(), newStageRef.name());

      // send ref updated event only if it changed
      if (!newStageRef.equals(oldStageRef)) {
        referenceUpdated.fire(
            projectKey, stagingBranchName, oldStageRef, newStageRef, user.state());
      }
    } catch (IOException e) {
      logger.atSevere().log(
          "qtcodereview: rebuild %s failed to update ref %s", stagingBranchKey, e);
      throw new MergeConflictException("fatal: IOException");
    }
  }

  /**
   * Lists not merged changes between branches.
   *
   * @param git jGit Repository. Must be open.
   * @param db ReviewDb of a Gerrit site.
   * @param branch Branch to search for the changes.
   * @param destination Destination branch for changes.
   * @return List of not merged changes.
   * @throws IOException Thrown by Repository or RevWalk if repository is not accessible.
   */
  public List<Map.Entry<ChangeData, RevCommit>> listChangesNotMerged(
      Repository git, final BranchNameKey branch, final BranchNameKey destination)
      throws IOException, BranchNotFoundException {

    Map<Change.Id, Map.Entry<ChangeData, RevCommit>> map = new HashMap<>();
    RevWalk revWalk = new RevWalk(git);

    try {
      Ref ref = git.getRefDatabase().getRef(branch.branch());
      if (ref == null) throw new BranchNotFoundException("No such branch: " + branch);
      Ref refDest = git.getRefDatabase().getRef(destination.branch());
      if (refDest == null) throw new BranchNotFoundException("No such branch: " + destination);
      RevCommit firstCommit = revWalk.parseCommit(ref.getObjectId());
      revWalk.markStart(firstCommit);
      // Destination is the walker end point
      revWalk.markUninteresting(revWalk.parseCommit(refDest.getObjectId()));

      Iterator<RevCommit> i = revWalk.iterator();
      while (i.hasNext()) {
        RevCommit commit = i.next();
        String changeId = getChangeId(commit);
        List<ChangeData> changes = null;

        if (changeId != null) {
          Change.Key key = Change.key(changeId);
          changes = queryProvider.get().byBranchKey(destination, key);
        }

        if (changes != null && !changes.isEmpty()) {
          if (changes.size() > 1)
            logger.atWarning().log(
                "qtcodereview: commit belongs to multiple changes: %s", commit.name());
          ChangeData cd = changes.get(0);
          map.put(cd.getId(), new AbstractMap.SimpleEntry<ChangeData, RevCommit>(cd, commit));
        }
      }
    } finally {
      revWalk.dispose();
    }
    return new ArrayList<Map.Entry<ChangeData, RevCommit>>(map.values());
  }

  public static RevCommit merge(
      PersonIdent committerIdent,
      Repository git,
      ObjectInserter objInserter,
      RevWalk revWalk,
      RevCommit toMerge,
      RevCommit mergeTip,
      String customCommitMessage,
      boolean mergeAlways)
      throws NoSuchRefException, IOException, MergeConflictException {

    if (revWalk.isMergedInto(toMerge, mergeTip)) {
      logger.atWarning().log("qtcodereview: commit %s already in %s", toMerge, mergeTip);
      return mergeTip; // already up to date
    }

    ThreeWayMerger merger = MergeStrategy.RESOLVE.newMerger(git, true);
    if (!merger.merge(mergeTip, toMerge)) {
      logger.atWarning().log("qtcodereview: merge conflict %s on top of %s", toMerge, mergeTip);
      throw new MergeConflictException("Merge conflict");
    }

    if (!mergeAlways && merger.getResultTreeId().equals(toMerge.getTree().toObjectId())) {
      // Just fast forward, note that this will bring in all dependencies from source
      logger.atInfo().log("qtcodereview: merge fast forward %s on top of %s", toMerge, mergeTip);
      return toMerge;
    }

    String message = customCommitMessage;
    if (message == null) {
      try {
          message = "Merge \"" + revWalk.parseCommit(toMerge).getShortMessage() + "\"";
        } catch (Exception e) {
          message = "Merge";
        }
    }

    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(merger.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, toMerge); // important: mergeTip must be parent index 0
    mergeCommit.setAuthor(committerIdent);
    mergeCommit.setCommitter(committerIdent);
    mergeCommit.setMessage(message);

    ObjectId commit = objInserter.insert(mergeCommit);
    objInserter.flush();
    return revWalk.parseCommit(commit);
  }

  public static RefUpdate.Result mergeBranches(
      IdentifiedUser user,
      Repository git,
      final BranchNameKey branch,
      final BranchNameKey destination,
      String customCommitMessage)
      throws NoSuchRefException, IOException, MergeConflictException {

    ObjectId srcId = git.resolve(branch.branch());
    if (srcId == null) throw new NoSuchRefException("Invalid Revision: " + branch);

    return mergeObjectToBranch(user, git, srcId, destination, customCommitMessage);
  }

  private static RefUpdate.Result mergeObjectToBranch(
      IdentifiedUser user,
      Repository git,
      ObjectId srcId,
      final BranchNameKey destination,
      String customCommitMessage)
      throws NoSuchRefException, IOException, MergeConflictException {

    Ref destRef = git.getRefDatabase().getRef(destination.branch());
    if (destRef == null) throw new NoSuchRefException("No such branch: " + destination);

    ObjectId destId = git.resolve(destination.branch());
    if (destId == null) throw new NoSuchRefException("Invalid Revision: " + destination);

    RevWalk revWalk = new RevWalk(git);
    try {

      ObjectInserter objInserter = git.newObjectInserter();
      RevCommit mergeTip = revWalk.lookupCommit(destId);
      RevCommit toMerge = revWalk.lookupCommit(srcId);
      PersonIdent committer =
          user.newCommitterIdent(new Timestamp(System.currentTimeMillis()), TimeZone.getDefault());

      RevCommit mergeCommit = merge(committer, git, objInserter, revWalk, toMerge,
                                    mergeTip, customCommitMessage, false);
      logger.atInfo().log("qtcodereview: merge commit for %s added to %s", srcId, destination);

      RefUpdate refUpdate = git.updateRef(destination.branch());
      refUpdate.setNewObjectId(mergeCommit);
      return refUpdate.update();
    } catch (Exception e) {
      logger.atWarning().log("qtcodereview: merge failed, %s", e);
      return null;
    } finally {
      revWalk.dispose();
    }
  }

  private RefUpdate.Result fastForwardBranch(Repository git,
      String branchName, ObjectId toObjectId) {

    RefUpdate.Result result = null;

    try {
      RefUpdate refUpdate = git.updateRef(branchName);
      refUpdate.setNewObjectId(toObjectId);
      refUpdate.setForceUpdate(false);
      result = refUpdate.update();
      logger.atInfo().log("fastforward branch %s to %s, result: %s", branchName,
          toObjectId.name(), result);
    } catch (Exception e) {
      result = null;
      logger.atWarning().log("fastforward failed for %s: %s", branchName, e);
    }

    return result;
  }

  private List<RevCommit> listCommitsInIntegrationBranch(Repository git,
      ObjectId integrationHeadId, ObjectId targetBranchHeadId) {

    List<RevCommit> commits = new ArrayList<RevCommit>();
    int count = 0;

    try {
      RevWalk revWalk = new RevWalk(git);
      RevCommit commit = revWalk.parseCommit(integrationHeadId);
      RevCommit targetHeadCommit = revWalk.parseCommit(targetBranchHeadId);

      do {
        if (revWalk.isMergedInto(commit, targetHeadCommit)) {
          commit = null;
        } else {
          commits.add(0, commit);
          if (commit.getParentCount() > 0) {
            // Qt Gerrit plugins's merges always have the branch as parent 0
            commit = revWalk.parseCommit(commit.getParent(0));
          } else commit = null;
        }
        count++;
      } while (commit != null && count < 100);
    } catch (Exception e) {
      commits = null;
      logger.atWarning().log("listing commits in a branch failed: %s", e);
    }

    if (count >= 100) {
      logger.atWarning().log("listing commits in a branch failed: too many commmits");
      return null;
    }

    return commits;
  }

  private Boolean isCherryPickingAllowed(List<RevCommit> commits) {
    // Cherry-picking merge commits is not allowed, because it would squash
    // the merge into one single commit
    for (RevCommit commit : commits) {
      if (commit.getParentCount() > 1) return false;
    }
    return true;
  }

  private List<RevCommit> cherryPickCommitsToBranch(Repository git,
      Project.NameKey project, String branchName, List<RevCommit> commits) {

    try {
      ProjectState projectState = projectCache.checkedGet(project);
      MergeUtil mergeUtil = mergeUtilFactory.create(projectState, true);
      ObjectInserter objInserter = git.newObjectInserter();
      ObjectReader reader = objInserter.newReader();
      CodeReviewCommit.CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(reader);
      RevCommit newBranchHead = revWalk.parseCommit(git.resolve(branchName));

      List<RevCommit> cherryPicked = new ArrayList<RevCommit>();

      for (RevCommit commit : commits) {
        CodeReviewCommit cherryPickCommit =
            mergeUtil.createCherryPickFromCommit(
                objInserter,
                git.getConfig(),
                newBranchHead,
                commit,
                new PersonIdent(commit.getCommitterIdent(), new Date()),
                commit.getFullMessage(),
                revWalk,
                0,
                true, // ignoreIdenticalTree
                false); // allowConflicts
        objInserter.flush();
        logger.atInfo().log("created cherrypick commit %s from %s", cherryPickCommit.name(),
            commit.name());
        newBranchHead = cherryPickCommit;
        cherryPicked.add(cherryPickCommit);
      }

      RefUpdate.Result result = fastForwardBranch(git, branchName, newBranchHead);
      if (result != RefUpdate.Result.FAST_FORWARD) return null;

      return cherryPicked;
    } catch (Exception e) {
      logger.atWarning().log("cherrypicking commits to branch failed: %s", e);
      return null;
    }
  }

  private List<Map.Entry<ChangeData, RevCommit>> listChanges(Repository git,
      BranchNameKey destination, List<RevCommit> commits) throws Exception {

    Map<Change.Id, Map.Entry<ChangeData, RevCommit>> map = new HashMap<>();

    for (RevCommit commit : commits) {
      String changeId = getChangeId(commit);
      List<ChangeData> changes = null;

      if (changeId == null && commit.getParentCount() > 1) {
        // Merge commit without Change-Id, so done by plugin: changes merged in will be parent 1
        changeId = getChangeId(commit.getParent(1));
      }

      if (changeId != null) {
        Change.Key key = Change.key(changeId);
        changes = queryProvider.get().byBranchKey(destination, key);
      }

      if (changes != null && !changes.isEmpty()) {
        if (changes.size() > 1) {
          String msg = String.format("Same Change-Id in several changes on same branch: %s",
              commit.name());
          throw new Exception(msg);
        }
        ChangeData cd = changes.get(0);
        map.put(cd.getId(), new AbstractMap.SimpleEntry<ChangeData, RevCommit>(cd, commit));
      }
    }
    return new ArrayList<Map.Entry<ChangeData, RevCommit>>(map.values());
  }

  public List<Map.Entry<ChangeData, RevCommit>> mergeIntegrationToBranch(
      IdentifiedUser user,
      Repository git,
      Project.NameKey project,
      final BranchNameKey integrationBranch,
      final BranchNameKey targetBranch,
      String customCommitMessage)
      throws MergeConflictException, NoSuchRefException {

    List<RevCommit> commitsInBranch = null;
    RevCommit newBranchHead = null;
    RefUpdate.Result result  = null;
    ObjectId sourceId = null;
    ObjectId targetId = null;

    logger.atInfo().log("start merging integration %s to %s", integrationBranch.branch(),
        targetBranch.branch());

    try {
      sourceId = git.resolve(integrationBranch.branch());
      if (sourceId == null) throw new NoSuchRefException("Invalid Revision: " + integrationBranch);

      Ref targetRef = git.getRefDatabase().getRef(targetBranch.branch());
      if (targetRef == null) throw new NoSuchRefException("No such branch: " + targetBranch);

      targetId = git.resolve(targetBranch.branch());
      if (targetId == null) throw new NoSuchRefException("Invalid Revision: " + targetBranch);

      if (sourceId.equals(targetId)) throw new NoSuchRefException("Nothing to merge");

      commitsInBranch = listCommitsInIntegrationBranch(git, sourceId, targetId);
      if (commitsInBranch == null)
          throw new NoSuchRefException("Failed to list commits in " + integrationBranch);
      else if (commitsInBranch.isEmpty())
          throw new NoSuchRefException("No commits in " + integrationBranch);
    } catch (Exception e) {
      logger.atWarning().log("preconditions of merging integration failed: %s", e);
      throw new NoSuchRefException(e.getMessage());
    }

    try {
      logger.atInfo().log("Trying to fast forward...");
      result = fastForwardBranch(git, targetBranch.branch(), sourceId);
      if (result == RefUpdate.Result.FAST_FORWARD)
        return listChanges(git, targetBranch, commitsInBranch);

      if (isCherryPickingAllowed(commitsInBranch)) {
        logger.atInfo().log("Trying to rebase integration onto the target branch...");
        List<RevCommit> cherrypicks = cherryPickCommitsToBranch(git, project, targetBranch.branch(), commitsInBranch);
        if (cherrypicks != null) return listChanges(git, targetBranch, cherrypicks);
      }

      logger.atInfo().log("Trying to create merge commit...");
      List<Map.Entry<ChangeData, RevCommit>> mergedCommits =
          listChangesNotMerged(git, integrationBranch, targetBranch);
      result = mergeBranches(user, git, integrationBranch, targetBranch, customCommitMessage);
      if (result != RefUpdate.Result.FAST_FORWARD) throw new Exception("Merge conflict");
      return mergedCommits;
    } catch (Exception e) {
      result = null;
      logger.atWarning().log("Merging integration %s to %s failed: %s",
          integrationBranch.branch(), targetBranch.branch(), e.getMessage());
      throw new MergeConflictException("Merge conflict:" + integrationBranch.branch() +
                                       " to " + targetBranch.branch());
    }
  }

  private Supplier<ChangeAttribute> changeAttributeSupplier(Change change, ChangeNotes notes) {
    return Suppliers.memoize(
        () -> {
          try {
            return eventFactory.asChangeAttribute(change, notes);
          } catch (StorageException e) {
            throw new RuntimeException(e);
          }
        });
  }

  public void postChangeStagedEvent(Change change) {
    try {
      ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
      QtChangeStagedEvent event = new QtChangeStagedEvent(change);
      event.change = changeAttributeSupplier(change, notes);
      eventDispatcher.get().postEvent(event);
    } catch (StorageException | PermissionBackendException e) {
      logger.atWarning().log("qtcodereview: postChangeStagedEvent failed: %s", e);
    }
  }

  public void postChangeUnStagedEvent(Change change) {
    try {
      ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
      QtChangeUnStagedEvent event = new QtChangeUnStagedEvent(change);
      event.change = changeAttributeSupplier(change, notes);
      eventDispatcher.get().postEvent(event);
    } catch (StorageException | PermissionBackendException e) {
      logger.atWarning().log("qtcodereview: postChangeUnStagedEvent failed: %s", e);
    }
  }

  public void postChangeIntegrationPassEvent(Change change) {
    try {
      ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
      QtChangeIntegrationPassEvent event = new QtChangeIntegrationPassEvent(change);
      event.change = changeAttributeSupplier(change, notes);
      eventDispatcher.get().postEvent(event);
    } catch (StorageException | PermissionBackendException e) {
      logger.atWarning().log("qtcodereview: postChangeIntegrationPassEvent failed: %s", e);
    }
  }

  public void postChangeIntegrationFailEvent(Change change) {
    try {
      ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
      QtChangeIntegrationFailEvent event = new QtChangeIntegrationFailEvent(change);
      event.change = changeAttributeSupplier(change, notes);
      eventDispatcher.get().postEvent(event);
    } catch (StorageException | PermissionBackendException e) {
      logger.atWarning().log("qtcodereview: postChangeIntegrationFailEvent failed: %s", e);
    }
  }

  public void postChangePreCheckEvent(Change change, PatchSet patchSet) {
    try {
      ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
      QtChangePreCheckEvent event = new QtChangePreCheckEvent(change);
      event.change = changeAttributeSupplier(change, notes);
      event.commitID = patchSet.commitId().name();
      eventDispatcher.get().postEvent(event);
    } catch (StorageException | PermissionBackendException e) {
      logger.atWarning().log("qtcodereview: postChangePreCheckEvent failed: %s", e);
    }
  }
}
