// Copyright (C) 2011 The Android Open Source Project
// Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
// Copyright (C) 2021 The Qt Company
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.googlesource.gerrit.plugins.qtcodereview;

import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.flogger.FluentLogger;
import com.google.gerrit.common.FooterConstants;
import com.google.gerrit.exceptions.StorageException;
import com.google.gerrit.extensions.registration.DynamicItem;
import com.google.gerrit.extensions.restapi.RestApiException;
import com.google.gerrit.entities.BranchNameKey;
import com.google.gerrit.entities.Change;
import com.google.gerrit.entities.PatchSet;
import com.google.gerrit.entities.Project;
import com.google.gerrit.server.ChangeMessagesUtil;
import com.google.gerrit.server.IdentifiedUser;
import com.google.gerrit.server.data.ChangeAttribute;
import com.google.gerrit.server.extensions.events.GitReferenceUpdated;
import com.google.gerrit.server.events.ChangeEvent;
import com.google.gerrit.server.events.EventDispatcher;
import com.google.gerrit.server.events.EventFactory;
import com.google.gerrit.server.notedb.ChangeNotes;
import com.google.gerrit.server.permissions.PermissionBackendException;
import com.google.gerrit.server.project.NoSuchRefException;
import com.google.gerrit.server.query.change.ChangeData;
import com.google.gerrit.server.query.change.InternalChangeQuery;
import com.google.gerrit.server.submit.IntegrationException;
import com.google.gerrit.server.update.BatchUpdate;
import com.google.gerrit.server.update.UpdateException;
import com.google.gerrit.server.util.time.TimeUtil;
import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.Singleton;
import java.io.IOException;
import java.sql.Timestamp;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;
import org.eclipse.jgit.errors.MissingObjectException;
import org.eclipse.jgit.lib.CommitBuilder;
import org.eclipse.jgit.lib.Constants;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.ObjectInserter;
import org.eclipse.jgit.lib.PersonIdent;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.lib.RefUpdate;
import org.eclipse.jgit.lib.RefUpdate.Result;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.merge.MergeStrategy;
import org.eclipse.jgit.merge.ThreeWayMerger;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.transport.ReceiveCommand;

/** Utility methods for working with git and database. */
@Singleton
public class QtUtil {

  private static final FluentLogger logger = FluentLogger.forEnclosingClass();

  public static final String R_HEADS = "refs/heads/";
  public static final String R_STAGING = "refs/staging/";
  public static final String R_BUILDS = "refs/builds/";
  public static final String TAG_CI = ChangeMessagesUtil.AUTOGENERATED_TAG_PREFIX + "qt:ci";
  public static final String TAG_ADMINCHANGE =
      ChangeMessagesUtil.AUTOGENERATED_TAG_PREFIX + "qt:adminchange";
  public static final String TAG_REOPENED =
      ChangeMessagesUtil.AUTOGENERATED_TAG_PREFIX + "qt:reopened";

  private final Provider<InternalChangeQuery> queryProvider;
  private final GitReferenceUpdated referenceUpdated;
  private final BatchUpdate.Factory updateFactory;
  private final ChangeNotes.Factory changeNotesFactory;
  private final DynamicItem<EventDispatcher> eventDispatcher;
  private final EventFactory eventFactory;
  private final QtCherryPickPatch qtCherryPickPatch;
  private final QtChangeUpdateOp.Factory qtUpdateFactory;
  private final QtEmailSender qtEmailSender;

  @Inject
  QtUtil(
      Provider<InternalChangeQuery> queryProvider,
      GitReferenceUpdated referenceUpdated,
      BatchUpdate.Factory updateFactory,
      ChangeNotes.Factory changeNotesFactory,
      EventFactory eventFactory,
      DynamicItem<EventDispatcher> eventDispatcher,
      QtCherryPickPatch qtCherryPickPatch,
      QtChangeUpdateOp.Factory qtUpdateFactory,
      QtEmailSender qtEmailSender) {
    this.queryProvider = queryProvider;
    this.referenceUpdated = referenceUpdated;
    this.updateFactory = updateFactory;
    this.changeNotesFactory = changeNotesFactory;
    this.eventDispatcher = eventDispatcher;
    this.eventFactory = eventFactory;
    this.qtCherryPickPatch = qtCherryPickPatch;
    this.qtUpdateFactory = qtUpdateFactory;
    this.qtEmailSender = qtEmailSender;
  }

  public static class MergeConflictException extends Exception {
    private static final long serialVersionUID = 1L;

    public MergeConflictException(final String message) {
      super(message);
    }
  }

  public static class BranchNotFoundException extends Exception {
    private static final long serialVersionUID = 1L;

    public BranchNotFoundException(final String message) {
      super(message);
    }
  }

  public static Project.NameKey getProjectKey(final String project) {
    String projectName = project;
    if (project.endsWith(Constants.DOT_GIT_EXT)) {
      projectName = project.substring(0, project.length() - Constants.DOT_GIT_EXT.length());
    }
    return Project.nameKey(projectName);
  }

  /**
   * Creates a branch key including ref prefix.
   *
   * @param project Project for the branch key.
   * @param prefix Expected prefix.
   * @param branch Branch name with or without prefix.
   * @return Branch name key with prefix.
   */
  public static BranchNameKey getNameKeyLong(
      final String project, final String prefix, final String branch) {
    final Project.NameKey projectKey = getProjectKey(project);
    if (branch.startsWith(prefix)) {
      return BranchNameKey.create(projectKey, branch);
    } else {
      return BranchNameKey.create(projectKey, prefix + branch);
    }
  }

  /**
   * Creates a branch key without any prefix.
   *
   * @param project Project for the branch key.
   * @param prefix Prefix to remove.
   * @param branch Branch name with or without prefix.
   * @return Branch name key without prefix.
   */
  public static BranchNameKey getNameKeyShort(
      final String project, final String prefix, final String branch) {
    final Project.NameKey projectKey = getProjectKey(project);
    if (branch.startsWith(prefix)) {
      return BranchNameKey.create(projectKey, branch.substring(prefix.length()));
    } else {
      return BranchNameKey.create(projectKey, branch);
    }
  }

  public static boolean branchExists(Repository git, final BranchNameKey branch)
      throws IOException {
    return git.getRefDatabase().getRef(branch.branch()) != null;
  }

  /**
   * Gets a staging branch for a branch.
   *
   * @param branch Branch under refs/heads. E.g. refs/heads/master. Can be short name.
   * @return Matching staging branch. E.g. refs/staging/master
   */
  public static BranchNameKey getStagingBranch(final BranchNameKey branch) {
    return getBranchWithNewPrefix(branch, R_HEADS, R_STAGING);
  }

  private static BranchNameKey getBranchWithNewPrefix(
      final BranchNameKey branch, final String oldPrefix, final String newPrefix) {
    final String ref = branch.branch();

    if (ref.startsWith(oldPrefix)) {
      // Create new ref replacing the old prefix with new.
      return BranchNameKey.create(
          branch.project(), newPrefix + ref.substring(oldPrefix.length()));
    }
    // Treat the ref as short name.
    return BranchNameKey.create(branch.project(), newPrefix + ref);
  }

  public static Result createStagingBranch(Repository git, final BranchNameKey sourceBranch) {
    try {
      final String sourceBranchName;
      if (sourceBranch.branch().startsWith(R_HEADS)) {
        sourceBranchName = sourceBranch.branch();
      } else {
        sourceBranchName = R_HEADS + sourceBranch.branch();
      }

      final String stagingBranch = R_STAGING + sourceBranch.shortName();

      return updateRef(git, stagingBranch, sourceBranchName, true);
    } catch (NoSuchRefException | IOException e) {
      return null;
    }
  }

  /**
   * Creates a build ref. Build refs are stored under refs/builds.
   *
   * @param git Git repository.
   * @param stagingBranch Staging branch to create the build ref from. Can be short name.
   * @param newBranch Build ref name, under refs/builds. Can be short name.
   * @return
   * @throws IOException
   * @throws NoSuchRefException
   */
  public Result createBuildRef(
      Repository git,
      IdentifiedUser user,
      final Project.NameKey projectKey,
      final BranchNameKey stagingBranch,
      final BranchNameKey newBranch)
      throws IOException, NoSuchRefException {
    final String stagingBranchName;
    if (stagingBranch.branch().startsWith(R_STAGING)) {
      stagingBranchName = stagingBranch.branch();
    } else {
      stagingBranchName = R_STAGING + stagingBranch.branch();
    }

    final String buildBranchName;
    if (newBranch.branch().startsWith(R_BUILDS)) {
      buildBranchName = newBranch.branch();
    } else {
      buildBranchName = R_BUILDS + newBranch.branch();
    }

    Ref sourceRef = git.getRefDatabase().getRef(stagingBranchName);
    if (sourceRef == null) {
      throw new NoSuchRefException(stagingBranchName);
    }

    RefUpdate refUpdate = git.updateRef(buildBranchName);
    refUpdate.setNewObjectId(sourceRef.getObjectId());
    refUpdate.setForceUpdate(false);
    RefUpdate.Result result = refUpdate.update();

    // send ref created event
    referenceUpdated.fire(projectKey, refUpdate, ReceiveCommand.Type.CREATE, user.state());

    return result;
  }

  private static Result updateRef(
      Repository git, final String ref, final String newValue, final boolean force)
      throws IOException, NoSuchRefException {
    Ref sourceRef = git.getRefDatabase().getRef(newValue);
    if (sourceRef == null) {
      throw new NoSuchRefException(newValue);
    }

    return updateRef(git, ref, sourceRef.getObjectId(), force);
  }

  public static Result updateRef(
      Repository git, final String ref, final ObjectId id, final boolean force)
      throws IOException, NoSuchRefException {
    RefUpdate refUpdate = git.updateRef(ref);
    refUpdate.setNewObjectId(id);
    refUpdate.setForceUpdate(force);
    RefUpdate.Result result = refUpdate.update();
    return result;
  }

  private static String getChangeId(RevCommit commit) {
    List<String> changeIds = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String changeId = null;
    if (!changeIds.isEmpty()) changeId = changeIds.get(0);
    return changeId;
  }

  private ChangeData findChangeFromList(String changeId, List<ChangeData> changes) {
    for (ChangeData item : changes) {
      if (item.change().getKey().get().equals(changeId)) return item;
    }
    return null;
  }

  // Step backwards from the ref and return change list in the same order
  private List<ChangeData> arrangeOrderLikeInRef(
      Repository git, ObjectId refObj, ObjectId tipObj, List<ChangeData> changeList)
      throws MissingObjectException, IOException {
    List<ChangeData> results = new ArrayList<ChangeData>();
    if (refObj.equals(tipObj)) return results;

    RevWalk revWalk = new RevWalk(git);
    RevCommit commit = revWalk.parseCommit(refObj);
    int count = 0;
    do {
      count++;
      String changeId = getChangeId(commit);

      if (commit.getParentCount() == 0) {
        commit = null; // something is going wrong, just exit
      } else {
        if (changeId == null && commit.getParentCount() > 1) {
          changeId = getChangeId(revWalk.parseCommit(commit.getParent(1)));
        }
        ChangeData change = findChangeFromList(changeId, changeList);
        if (change != null) results.add(0, change);

        // It can always be trusted that parent in index 0 is the correct one
        commit = revWalk.parseCommit(commit.getParent(0));
      }
    } while (commit != null && !commit.equals(tipObj) && count < 100);

    if (count == 100) return null;
    return results;
  }

  private ObjectId pickChangesToStagingRef(
      Repository git, final Project.NameKey projectKey, List<ChangeData> changes, ObjectId tipObj)
      throws IOException, IntegrationException {
    ObjectId newId = tipObj;
    for (ChangeData item : changes) {
      Change change = item.change();
      logger.atInfo().log("qtcodereview: rebuilding add %s", change);
      PatchSet p = item.currentPatchSet();
      ObjectId srcId = git.resolve(p.commitId().name());
      newId =
          qtCherryPickPatch
              .cherryPickPatch(
                  item,
                  projectKey,
                  srcId,
                  newId,
                  false, // allowFastForward
                  null, // newStatus
                  null, // defaultMessage
                  null, // inputMessage
                  TAG_CI // tag
                  )
              .toObjectId();
    }
    return newId;
  }

  // Step backwards from staging head and find commit that can be reused
  private ObjectId findReusableStagingHead(
      Repository git,
      ObjectId stagingHead,
      ObjectId branchHead,
      List<ChangeData> stagedChanges)
      throws MissingObjectException, IOException {

    if (stagingHead.equals(branchHead)) return branchHead;

    ObjectId reusableHead = null;
    RevWalk revWalk = new RevWalk(git);
    RevCommit commit = revWalk.parseCommit(stagingHead);
    int count = 0;
    do {
      count++;
      String changeId = getChangeId(commit);
      ChangeData change = findChangeFromList(changeId, stagedChanges);
      if (change != null) {
        if (reusableHead == null) reusableHead = commit;
      } else reusableHead = null;

      if (commit.getParentCount() > 0) {
        // It can always be trusted that parent in index 0 is the correct one
        commit = revWalk.parseCommit(commit.getParent(0));
      } else commit = null;

    } while (commit != null && !commit.equals(branchHead) && count < 100);

    if (reusableHead == null) reusableHead = branchHead;
    return reusableHead;
  }

  public void rebuildStagingBranch(
      Repository git,
      IdentifiedUser user,
      final Project.NameKey projectKey,
      final BranchNameKey stagingBranchKey,
      final BranchNameKey destBranchShortKey)
      throws MergeConflictException {
    InternalChangeQuery query = null;
    List<ChangeData> changes_staged = null;
    List<ChangeData> changes_to_cherrypick = null;
    ObjectId oldStageRef = null;
    ObjectId branchRef = null;
    ObjectId newStageRef = null;
    String stagingBranchName = null;

    try {
      stagingBranchName = stagingBranchKey.branch();
      oldStageRef = git.resolve(stagingBranchName);
      branchRef = git.resolve(destBranchShortKey.branch());

      query = queryProvider.get();
      changes_staged = query.byBranchStatus(destBranchShortKey, Change.Status.STAGED);
    } catch (IOException e) {
      logger.atSevere().log(
          "qtcodereview: rebuild staging ref %s db query failed. Exception %s",
          stagingBranchKey, e);
      throw new MergeConflictException("fatal: " + e.getMessage());
    }

    try {
      logger.atInfo().log(
          "qtcodereview: rebuild staging ref reset %s back to %s",
          stagingBranchKey, destBranchShortKey);
      Result result = QtUtil.createStagingBranch(git, destBranchShortKey);
      if (result == null)
        throw new NoSuchRefException("Cannot create staging ref: " + stagingBranchName);
      logger.atInfo().log(
          "qtcodereview: rebuild staging ref reset to %s with result %s", branchRef, result);
      newStageRef = findReusableStagingHead(git, oldStageRef, branchRef, changes_staged);
      logger.atInfo().log("qtcodereview: rebuild staging reused staging ref is %s", newStageRef);
      changes_to_cherrypick = arrangeOrderLikeInRef(git, oldStageRef, newStageRef, changes_staged);
    } catch (NoSuchRefException | IOException e) {
      logger.atSevere().log(
          "qtcodereview: rebuild staging ref reset %s failed. Exception %s", stagingBranchKey, e);
      throw new MergeConflictException("fatal: " + e.getMessage());
    }

    try {
      newStageRef = pickChangesToStagingRef(git, projectKey, changes_to_cherrypick, newStageRef);
    } catch (Exception e) {
      logger.atInfo().log("qtcodereview: rebuild staging ref %s merge conflict", stagingBranchKey);
      newStageRef = branchRef;
      String message =
          "Merge conflict in staging branch. Status changed back to new. Please stage again.";
      QtChangeUpdateOp op =
          qtUpdateFactory.create(
              Change.Status.NEW, Change.Status.STAGED, message, null, null, null);
      try (BatchUpdate u = updateFactory.create(projectKey, user, TimeUtil.nowTs())) {
        for (ChangeData item : changes_staged) {
          Change change = item.change();
          logger.atInfo().log(
              "qtcodereview: staging ref rebuild merge conflict. Change %s back to NEW", change);
          u.addOp(change.getId(), op);
        }
        u.execute();
      } catch (UpdateException | RestApiException ex) {
        logger.atSevere().log(
            "qtcodereview: staging ref rebuild. Failed to update change status %s", ex);
      }

      for (ChangeData item : changes_staged) {
        Change change = item.change();
        qtEmailSender.sendBuildFailedEmail(projectKey, change.getId(), user.getAccountId(),
            message);
      }
    }

    try {
      RefUpdate refUpdate = git.updateRef(stagingBranchName);
      refUpdate.setNewObjectId(newStageRef);
      refUpdate.update();

      // send ref updated event only if it changed
      if (!newStageRef.equals(oldStageRef)) {
        referenceUpdated.fire(
            projectKey, stagingBranchName, oldStageRef, newStageRef, user.state());
      }
    } catch (IOException e) {
      logger.atSevere().log(
          "qtcodereview: rebuild %s failed to update ref %s", stagingBranchKey, e);
      throw new MergeConflictException("fatal: IOException");
    }
  }

  /**
   * Lists not merged changes between branches.
   *
   * @param git jGit Repository. Must be open.
   * @param db ReviewDb of a Gerrit site.
   * @param branch Branch to search for the changes.
   * @param destination Destination branch for changes.
   * @return List of not merged changes.
   * @throws IOException Thrown by Repository or RevWalk if repository is not accessible.
   */
  public List<Map.Entry<ChangeData, RevCommit>> listChangesNotMerged(
      Repository git, final BranchNameKey branch, final BranchNameKey destination)
      throws IOException, BranchNotFoundException {

    Map<Change.Id, Map.Entry<ChangeData, RevCommit>> map = new HashMap<>();
    RevWalk revWalk = new RevWalk(git);

    try {
      Ref ref = git.getRefDatabase().getRef(branch.branch());
      if (ref == null) throw new BranchNotFoundException("No such branch: " + branch);
      Ref refDest = git.getRefDatabase().getRef(destination.branch());
      if (refDest == null) throw new BranchNotFoundException("No such branch: " + destination);
      RevCommit firstCommit = revWalk.parseCommit(ref.getObjectId());
      revWalk.markStart(firstCommit);
      // Destination is the walker end point
      revWalk.markUninteresting(revWalk.parseCommit(refDest.getObjectId()));

      Iterator<RevCommit> i = revWalk.iterator();
      while (i.hasNext()) {
        RevCommit commit = i.next();
        String changeId = getChangeId(commit);
        List<ChangeData> changes = null;

        if (changeId != null) {
          Change.Key key = Change.key(changeId);
          changes = queryProvider.get().byBranchKey(destination, key);
        }

        if (changes != null && !changes.isEmpty()) {
          if (changes.size() > 1)
            logger.atWarning().log(
                "qtcodereview: commit belongs to multiple changes: %s", commit.name());
          ChangeData cd = changes.get(0);
          map.put(cd.getId(), new AbstractMap.SimpleEntry<ChangeData, RevCommit>(cd, commit));
        }
      }
    } finally {
      revWalk.dispose();
    }
    return new ArrayList<Map.Entry<ChangeData, RevCommit>>(map.values());
  }

  public static RevCommit merge(
      PersonIdent committerIdent,
      Repository git,
      ObjectInserter objInserter,
      RevWalk revWalk,
      RevCommit toMerge,
      RevCommit mergeTip,
      String customCommitMessage,
      boolean mergeAlways)
      throws NoSuchRefException, IOException, MergeConflictException {

    if (revWalk.isMergedInto(toMerge, mergeTip)) {
      logger.atWarning().log("qtcodereview: commit %s already in %s", toMerge, mergeTip);
      return mergeTip; // already up to date
    }

    ThreeWayMerger merger = MergeStrategy.RESOLVE.newMerger(git, true);
    if (!merger.merge(mergeTip, toMerge)) {
      logger.atWarning().log("qtcodereview: merge conflict %s on top of %s", toMerge, mergeTip);
      throw new MergeConflictException("Merge conflict");
    }

    if (!mergeAlways && merger.getResultTreeId().equals(toMerge.getTree().toObjectId())) {
      // Just fast forward, note that this will bring in all dependencies from source
      logger.atInfo().log("qtcodereview: merge fast forward %s on top of %s", toMerge, mergeTip);
      return toMerge;
    }

    String message = customCommitMessage;
    if (message == null) {
      try {
          message = revWalk.parseCommit(toMerge).getShortMessage();
        } catch (Exception e) {
          message = toMerge.toString();
        }
      message = "Merge \"" + toMerge.toString() + "\"";
    }

    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(merger.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, toMerge); // important: mergeTip must be parent index 0
    mergeCommit.setAuthor(committerIdent);
    mergeCommit.setCommitter(committerIdent);
    mergeCommit.setMessage(message);

    ObjectId commit = objInserter.insert(mergeCommit);
    objInserter.flush();
    return revWalk.parseCommit(commit);
  }

  public static RefUpdate.Result mergeBranches(
      IdentifiedUser user,
      Repository git,
      final BranchNameKey branch,
      final BranchNameKey destination,
      String customCommitMessage)
      throws NoSuchRefException, IOException, MergeConflictException {

    ObjectId srcId = git.resolve(branch.branch());
    if (srcId == null) throw new NoSuchRefException("Invalid Revision: " + branch);

    return mergeObjectToBranch(user, git, srcId, destination, customCommitMessage);
  }

  private static RefUpdate.Result mergeObjectToBranch(
      IdentifiedUser user,
      Repository git,
      ObjectId srcId,
      final BranchNameKey destination,
      String customCommitMessage)
      throws NoSuchRefException, IOException, MergeConflictException {

    Ref destRef = git.getRefDatabase().getRef(destination.branch());
    if (destRef == null) throw new NoSuchRefException("No such branch: " + destination);

    ObjectId destId = git.resolve(destination.branch());
    if (destId == null) throw new NoSuchRefException("Invalid Revision: " + destination);

    RevWalk revWalk = new RevWalk(git);
    try {

      ObjectInserter objInserter = git.newObjectInserter();
      RevCommit mergeTip = revWalk.lookupCommit(destId);
      RevCommit toMerge = revWalk.lookupCommit(srcId);
      PersonIdent committer =
          user.newCommitterIdent(new Timestamp(System.currentTimeMillis()), TimeZone.getDefault());

      RevCommit mergeCommit = merge(committer, git, objInserter, revWalk, toMerge,
                                    mergeTip, customCommitMessage, false);
      logger.atInfo().log("qtcodereview: merge commit for %s added to %s", srcId, destination);

      RefUpdate refUpdate = git.updateRef(destination.branch());
      refUpdate.setNewObjectId(mergeCommit);
      return refUpdate.update();
    } catch (Exception e) {
      logger.atWarning().log("qtcodereview: merge failed, %s", e);
      return null;
    } finally {
      revWalk.dispose();
    }
  }

  private Supplier<ChangeAttribute> changeAttributeSupplier(Change change, ChangeNotes notes) {
    return Suppliers.memoize(
        () -> {
          try {
            return eventFactory.asChangeAttribute(change, notes);
          } catch (StorageException e) {
            throw new RuntimeException(e);
          }
        });
  }

  public void postChangeStagedEvent(Change change) {
    try {
      ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
      QtChangeStagedEvent event = new QtChangeStagedEvent(change);
      event.change = changeAttributeSupplier(change, notes);
      eventDispatcher.get().postEvent(event);
    } catch (StorageException | PermissionBackendException e) {
      logger.atWarning().log("qtcodereview: postChangeStagedEvent failed: %s", e);
    }
  }

  public void postChangeUnStagedEvent(Change change) {
    try {
      ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
      QtChangeUnStagedEvent event = new QtChangeUnStagedEvent(change);
      event.change = changeAttributeSupplier(change, notes);
      eventDispatcher.get().postEvent(event);
    } catch (StorageException | PermissionBackendException e) {
      logger.atWarning().log("qtcodereview: postChangeUnStagedEvent failed: %s", e);
    }
  }

  public void postChangeIntegrationPassEvent(Change change) {
    try {
      ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
      QtChangeIntegrationPassEvent event = new QtChangeIntegrationPassEvent(change);
      event.change = changeAttributeSupplier(change, notes);
      eventDispatcher.get().postEvent(event);
    } catch (StorageException | PermissionBackendException e) {
      logger.atWarning().log("qtcodereview: postChangeIntegrationPassEvent failed: %s", e);
    }
  }

  public void postChangeIntegrationFailEvent(Change change) {
    try {
      ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
      QtChangeIntegrationFailEvent event = new QtChangeIntegrationFailEvent(change);
      event.change = changeAttributeSupplier(change, notes);
      eventDispatcher.get().postEvent(event);
    } catch (StorageException | PermissionBackendException e) {
      logger.atWarning().log("qtcodereview: postChangeIntegrationFailEvent failed: %s", e);
    }
  }

  public void postChangePreCheckEvent(Change change, PatchSet patchSet) {
    try {
      ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
      QtChangePreCheckEvent event = new QtChangePreCheckEvent(change);
      event.change = changeAttributeSupplier(change, notes);
      event.commitID = patchSet.commitId().name();
      eventDispatcher.get().postEvent(event);
    } catch (StorageException | PermissionBackendException e) {
      logger.atWarning().log("qtcodereview: postChangePreCheckEvent failed: %s", e);
    }
  }
}
